run_zsh_setup() {
    # Run ssh agent if not in an ssh session
    if currently_in_ssh_tty; then
        setup_ssh_session
        if test -z $ZSH_EXECUTION_STRING; then
            launch_multiplexer
        fi
    else
        start_or_connect_to_ssh_agent
    fi
}

currently_in_ssh_tty() {
    test -n "$SSH_TTY"
}

currently_in_ssh_session() {
    if currently_in_ssh_tty; then
        return 0
    elif test -n "$TMUX_PANE"; then
        base_tty_of_tmux_session=$(tmux list-clients -t ${TMUX_PANE:1} -F '#{client_tty}')
        if who | grep "${base_tty_of_tmux_session:5} " > /dev/null; then
            return 0
        fi
    fi
    return 1
}

have_ssh_agent() {
    test -n "$SSH_AUTH_SOCK"
}

have_remote_ssh_agent() {
    have_ssh_agent && test -z $SSH_AGENT_PID
}

setup_ssh_session() {
    echo $DISPLAY > ~/.display.txt
    if have_remote_ssh_agent
    then
        echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK; export SSH_AUTH_SOCK;" > ~/.ssh-agent-thing-remote
        export WANTS_REMOTE_SSH_AGENT='true'
    else
        start_or_connect_to_ssh_agent
    fi
}

start_or_connect_to_ssh_agent() {
    if ! pgrep -u "$USER" ssh-agent > /dev/null; then
        ssh-agent > ~/.ssh-agent-thing
        eval "$(<~/.ssh-agent-thing)" > /dev/null
    fi
    if [[ "$SSH_AGENT_PID" == "" ]]; then
        eval "$(<~/.ssh-agent-thing)" > /dev/null
    fi
}

launch_multiplexer() {
    if which tmux >/dev/null 2>&1
    then
        launch_tmux
    elif which screen >/dev/null 2>&1
    then
        launch_screen
    fi
}

launch_tmux() {
    # if not already inside a tmux session...
    if test -z "$TMUX"; then
        echo really launch
        # attach to any unused sessions, or start a new session
        # tmux ls
        # echo "get session"
        session=$(tmux ls | grep -v attached | head -1 | cut -f1 -d:)
        if [[ $session == "" ]]; then
            # echo "new $TERM"
            tmux new-session
        else
            # echo "attach: $session"
            tmux attach -t $session
        fi
   fi
   # when quitting tmux, quit totally
   while test -z ${TMUX}; do
       exit
   done
}

launch_screen() {
    # if not already inside a screen session...
    if test -z "$STY"; then
        # attach to any unused sessions, or start a new session
        screen -RR
    fi
    # when quitting screen, quit totally
    while test -z ${STY}; do
        exit
    done
}

run_zsh_setup
source /etc/profile

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
if [[ -r "/usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme" ]]; then
    source "/usr/share/zsh-theme-powerlevel10k/powerlevel10k.zsh-theme"
else
    source "${HOME}/.powerlevel10k/powerlevel10k.zsh-theme"
fi
# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

# Automatic zsh configuration
zstyle ':completion:*' completer _expand _complete _ignored _approximate
zstyle ':completion:*' completions 1
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' glob 1
zstyle ':completion:*' insert-unambiguous true
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' '+m:{[:lower:]}={[:upper:]} m:{[:lower:][:upper:]}={[:upper:][:lower:]}' '+r:|[._-]=** r:|=** l:|=*'
zstyle ':completion:*' max-errors 3
zstyle ':completion:*' menu select=long
zstyle ':completion:*' original true
zstyle ':completion:*' preserve-prefix '//[^/]##/'
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' substitute 1
zstyle ':completion:*' verbose true
zstyle :compinstall filename "$HOME/.zshrc"
autoload -Uz compinit
compinit

# Source system specific settings
source ~/.zprofile

HISTFILE=~/.histfile
HISTSIZE=16384
SAVEHIST=262144
setopt hist_ignore_dups hist_find_no_dups hist_ignore_space
setopt sharehistory appendhistory autocd extendedglob nomatch notify prompt_subst
setopt correct
bindkey -v

autoload -U colors && colors

# Vim-like bindings
bindkey "^R" history-incremental-search-backward
bindkey -a "/" history-incremental-search-backward
bindkey -a "k" vi-down-line-or-history
bindkey -a "j" up-line-or-history
bindkey -v "^[[8~" end-of-line
bindkey -a "^[[8~" vi-end-of-line
bindkey -v "^[[7~" beginning-of-line
bindkey -a "^[[7~" vi-beginning-of-line

export EDITOR="vim"

alias :q="exit"
alias ls='ls --color'
alias ll='ls --color -lah'
alias vi='vim'
alias rm='rm -i'
alias grep='grep --color'

spin() {
    set +o monitor
    cmd=$1
    spin='⠋⠙⠚⠞⠖⠦⠴⠲⠳⠓'
    #spin='/-\|'
    i=0
    eval $cmd >/dev/null &
    pid=$!
    while kill -0 $pid &>/dev/null; do
        i=$(((i + 1) % 10))
        printf "$fg[magenta]\r${spin:$i:1}"
        printf "$fg[white] $2"
        sleep .1
    done
    wait $pid
    code=$?
    if [[ $code == 0 ]] then
        mark="$fg[green]✓"
    else
        mark="$fg[red]✗"
    fi
    printf "\r$mark\n$fg[white]"
    return $code
}

dbuild() {
    name=$(basename $PWD)
    build_cmd="podman build --secret id=git_credentials,src=/home/lagoyd/cred -t $name ."
    if [[ $1 == "-v" ]] then
        eval $build_cmd
        shift
    elif [[ $1 == "-q" ]] then
        eval $build_cmd >/dev/null
        shift
    else
        spin $build_cmd "building container $name"
    fi
}

drun() {
    name=$(basename $PWD)
    podman run --rm -it -v $PWD:/usr/local/src/$name -w /usr/local/src/$name $name $@
}

history(){
    command sed 's/^. [0-9]*...//' < $HOME/.histfile | grep -i --color "$@"
}
alias hist='history'

precmd() {
    if currently_in_ssh_session
    then
        export DISPLAY=$(cat ~/.display.txt)
        if [[ $WANTS_REMOTE_SSH_AGENT == 'true' ]]
        then
            eval "$(<~/.ssh-agent-thing-remote)" > /dev/null
        fi
    fi
}


